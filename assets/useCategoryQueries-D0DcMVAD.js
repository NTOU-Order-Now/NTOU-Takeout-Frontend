var L=r=>{throw TypeError(r)};var M=(r,e,s)=>e.has(r)||L("Cannot "+s);var n=(r,e,s)=>(M(r,e,"read from private field"),s?s.call(r):e.get(r)),b=(r,e,s)=>e.has(r)?L("Cannot add the same private member more than once"):e instanceof WeakSet?e.add(r):e.set(r,s),h=(r,e,s,t)=>(M(r,e,"write to private field"),t?t.call(r,s):e.set(r,s),s),d=(r,e,s)=>(M(r,e,"access private method"),s);import{S as K,o as D,p as T,Q as G,u as _,q as j,s as J,r as C,t as V,v as W,w as X,x as Y,y as z,z as N,B as Z,D as ee,A as se,b as te}from"./index-NGzkvcc4.js";function U(r,e){return r.filter(s=>!e.includes(s))}function re(r,e,s){const t=r.slice(0);return t[e]=s,t}var Q,f,R,E,p,O,q,S,a,P,k,B,A,F,$,ie=($=class extends K{constructor(e,s,t){super();b(this,a);b(this,Q);b(this,f);b(this,R);b(this,E);b(this,p);b(this,O);b(this,q);b(this,S);h(this,Q,e),h(this,E,t),h(this,R,[]),h(this,p,[]),h(this,f,[]),this.setQueries(s)}onSubscribe(){this.listeners.size===1&&n(this,p).forEach(e=>{e.subscribe(s=>{d(this,a,A).call(this,e,s)})})}onUnsubscribe(){this.listeners.size||this.destroy()}destroy(){this.listeners=new Set,n(this,p).forEach(e=>{e.destroy()})}setQueries(e,s,t){h(this,R,e),h(this,E,s),D.batch(()=>{const i=n(this,p),o=d(this,a,B).call(this,n(this,R));o.forEach(c=>c.observer.setOptions(c.defaultedQueryOptions,t));const u=o.map(c=>c.observer),y=u.map(c=>c.getCurrentResult()),v=u.some((c,w)=>c!==i[w]);i.length===u.length&&!v||(h(this,p,u),h(this,f,y),this.hasListeners()&&(U(i,u).forEach(c=>{c.destroy()}),U(u,i).forEach(c=>{c.subscribe(w=>{d(this,a,A).call(this,c,w)})}),d(this,a,F).call(this)))})}getCurrentResult(){return n(this,f)}getQueries(){return n(this,p).map(e=>e.getCurrentQuery())}getObservers(){return n(this,p)}getOptimisticResult(e,s){const i=d(this,a,B).call(this,e).map(o=>o.observer.getOptimisticResult(o.defaultedQueryOptions));return[i,o=>d(this,a,k).call(this,o??i,s),()=>d(this,a,P).call(this,i,e)]}},Q=new WeakMap,f=new WeakMap,R=new WeakMap,E=new WeakMap,p=new WeakMap,O=new WeakMap,q=new WeakMap,S=new WeakMap,a=new WeakSet,P=function(e,s){const t=d(this,a,B).call(this,s);return t.map((i,o)=>{const u=e[o];return i.defaultedQueryOptions.notifyOnChangeProps?u:i.observer.trackResult(u,y=>{t.forEach(v=>{v.observer.trackProp(y)})})})},k=function(e,s){return s?((!n(this,O)||n(this,f)!==n(this,S)||s!==n(this,q))&&(h(this,q,s),h(this,S,n(this,f)),h(this,O,T(n(this,O),s(e)))),n(this,O)):e},B=function(e){const s=new Map(n(this,p).map(i=>[i.options.queryHash,i])),t=[];return e.forEach(i=>{const o=n(this,Q).defaultQueryOptions(i),u=s.get(o.queryHash);u?t.push({defaultedQueryOptions:o,observer:u}):t.push({defaultedQueryOptions:o,observer:new G(n(this,Q),o)})}),t},A=function(e,s){const t=n(this,p).indexOf(e);t!==-1&&(h(this,f,re(n(this,f),t,s)),d(this,a,F).call(this))},F=function(){var e;if(this.hasListeners()){const s=n(this,O),t=d(this,a,k).call(this,d(this,a,P).call(this,n(this,f),n(this,R)),(e=n(this,E))==null?void 0:e.combine);s!==t&&D.batch(()=>{this.listeners.forEach(i=>{i(n(this,f))})})}},$);function ne({queries:r,...e},s){const t=_(),i=j(),o=J(),u=C.useMemo(()=>r.map(l=>{const g=t.defaultQueryOptions(l);return g._optimisticResults=i?"isRestoring":"optimistic",g}),[r,t,i]);u.forEach(l=>{V(l),W(l,o)}),X(o);const[y]=C.useState(()=>new ie(t,u,e)),[v,c,w]=y.getOptimisticResult(u,e.combine);C.useSyncExternalStore(C.useCallback(l=>i?Y:y.subscribe(D.batchCalls(l)),[y,i]),()=>y.getCurrentResult(),()=>y.getCurrentResult()),C.useEffect(()=>{y.setQueries(u,e,{listeners:!1})},[u,e,y]);const H=v.some((l,g)=>z(u[g],l))?v.flatMap((l,g)=>{const m=u[g];if(m){const I=new G(t,m);if(z(m,l))return N(m,I,o);Z(l,i)&&N(m,I,o)}return[]}):[];if(H.length>0)throw Promise.all(H);const x=v.find((l,g)=>{const m=u[g];return m&&ee({result:l,errorResetBoundary:o,throwOnError:m.throwOnError,query:t.getQueryCache().get(m.queryHash)})});if(x!=null&&x.error)throw x.error;return c(w())}const oe=async(r,e,s)=>{try{return(await se.get(`/v2/menu/${r}/dishes`,{params:{category:e},signal:s})).data.data}catch(t){if(te.isCancel(t)){console.debug("Get dishes request cancelled");return}throw console.error(`Failed to fetch dishes by category: ${e}`,t),t}},he=(r,e,s)=>ne({queries:r.map(t=>({queryKey:["categoryDishes",t.categoryName],queryFn:async({signal:i})=>{const o=await oe(e,t.categoryName,i);return{categoryName:t.categoryName,dishes:o}},enabled:!!r&&!!e&&t.dishIds.length>0&&s,refetchOnWindowFocus:!1,staleTime:1/0})),combine:t=>({categoryData:t.map(i=>i.data).filter(Boolean),isQueriesSuccess:t.every(i=>i.isSuccess)})});export{he as u};
