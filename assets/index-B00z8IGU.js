import{a1 as I,ac as N,ad as S,ae as m,af as F,r as b}from"./index-CFrlWo3n.js";var Q=class extends I{constructor(e,t){super(e,t)}bindMethods(){super.bindMethods(),this.fetchNextPage=this.fetchNextPage.bind(this),this.fetchPreviousPage=this.fetchPreviousPage.bind(this)}setOptions(e,t){super.setOptions({...e,behavior:N()},t)}getOptimisticResult(e){return e.behavior=N(),super.getOptimisticResult(e)}fetchNextPage(e){return this.fetch({...e,meta:{fetchMore:{direction:"forward"}}})}fetchPreviousPage(e){return this.fetch({...e,meta:{fetchMore:{direction:"backward"}}})}createResult(e,t){var g,P;const{state:s}=e,c=super.createResult(e,t),{isFetching:o,isRefetching:a,isError:n,isRefetchError:r}=c,i=(P=(g=s.fetchMeta)==null?void 0:g.fetchMore)==null?void 0:P.direction,f=n&&i==="forward",u=o&&i==="forward",h=n&&i==="backward",l=o&&i==="backward";return{...c,fetchNextPage:this.fetchNextPage,fetchPreviousPage:this.fetchPreviousPage,hasNextPage:S(t,s.data),hasPreviousPage:m(t,s.data),isFetchNextPageError:f,isFetchingNextPage:u,isFetchPreviousPageError:h,isFetchingPreviousPage:l,isRefetchError:r&&!f&&!h,isRefetching:a&&!u&&!l}}};function $(e,t){return F(e,Q)}var y=new Map,w=new WeakMap,O=0,A=void 0;function B(e){return e?(w.has(e)||(O+=1,w.set(e,O.toString())),w.get(e)):"0"}function V(e){return Object.keys(e).sort().filter(t=>e[t]!==void 0).map(t=>`${t}_${t==="root"?B(e.root):e[t]}`).toString()}function C(e){const t=V(e);let s=y.get(t);if(!s){const c=new Map;let o;const a=new IntersectionObserver(n=>{n.forEach(r=>{var i;const f=r.isIntersecting&&o.some(u=>r.intersectionRatio>=u);e.trackVisibility&&typeof r.isVisible>"u"&&(r.isVisible=f),(i=c.get(r.target))==null||i.forEach(u=>{u(f,r)})})},e);o=a.thresholds||(Array.isArray(e.threshold)?e.threshold:[e.threshold||0]),s={id:t,observer:a,elements:c},y.set(t,s)}return s}function T(e,t,s={},c=A){if(typeof window.IntersectionObserver>"u"&&c!==void 0){const i=e.getBoundingClientRect();return t(c,{isIntersecting:c,target:e,intersectionRatio:typeof s.threshold=="number"?s.threshold:0,time:0,boundingClientRect:i,intersectionRect:i,rootBounds:i}),()=>{}}const{id:o,observer:a,elements:n}=C(s),r=n.get(e)||[];return n.has(e)||n.set(e,r),r.push(t),a.observe(e),function(){r.splice(r.indexOf(t),1),r.length===0&&(n.delete(e),a.unobserve(e)),n.size===0&&(a.disconnect(),y.delete(o))}}function j({threshold:e,delay:t,trackVisibility:s,rootMargin:c,root:o,triggerOnce:a,skip:n,initialInView:r,fallbackInView:i,onChange:f}={}){var u;const[h,l]=b.useState(null),R=b.useRef(),[g,P]=b.useState({inView:!!r,entry:void 0});R.current=f,b.useEffect(()=>{if(n||!h)return;let v;return v=T(h,(M,p)=>{P({inView:M,entry:p}),R.current&&R.current(M,p),p.isIntersecting&&a&&v&&(v(),v=void 0)},{root:o,rootMargin:c,threshold:e,trackVisibility:s,delay:t},i),()=>{v&&v()}},[Array.isArray(e)?e.toString():e,h,o,c,a,n,s,i,t]);const x=(u=g.entry)==null?void 0:u.target,E=b.useRef();!h&&x&&!a&&!n&&E.current!==x&&(E.current=x,P({inView:!!r,entry:void 0}));const d=[l,g.inView,g.entry];return d.ref=d[0],d.inView=d[1],d.entry=d[2],d}export{$ as a,j as u};
