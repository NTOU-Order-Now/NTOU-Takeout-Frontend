var L=r=>{throw TypeError(r)};var B=(r,e,s)=>e.has(r)||L("Cannot "+s);var n=(r,e,s)=>(B(r,e,"read from private field"),s?s.call(r):e.get(r)),b=(r,e,s)=>e.has(r)?L("Cannot add the same private member more than once"):e instanceof WeakSet?e.add(r):e.set(r,s),h=(r,e,s,t)=>(B(r,e,"write to private field"),t?t.call(r,s):e.set(r,s),s),d=(r,e,s)=>(B(r,e,"access private method"),s);import{Z as K,$ as P,a0 as T,a1 as G,u as Z,a2 as _,a3 as j,r as w,a4 as J,a5 as V,a6 as W,a7 as X,a8 as N,a9 as $,aa as Y,ab as ee,A as se,b as te}from"./index-CFrlWo3n.js";function z(r,e){return r.filter(s=>!e.includes(s))}function re(r,e,s){const t=r.slice(0);return t[e]=s,t}var Q,f,v,E,p,O,q,S,u,k,A,M,D,F,U,ie=(U=class extends K{constructor(e,s,t){super();b(this,u);b(this,Q);b(this,f);b(this,v);b(this,E);b(this,p);b(this,O);b(this,q);b(this,S);h(this,Q,e),h(this,E,t),h(this,v,[]),h(this,p,[]),h(this,f,[]),this.setQueries(s)}onSubscribe(){this.listeners.size===1&&n(this,p).forEach(e=>{e.subscribe(s=>{d(this,u,D).call(this,e,s)})})}onUnsubscribe(){this.listeners.size||this.destroy()}destroy(){this.listeners=new Set,n(this,p).forEach(e=>{e.destroy()})}setQueries(e,s,t){h(this,v,e),h(this,E,s),P.batch(()=>{const i=n(this,p),a=d(this,u,M).call(this,n(this,v));a.forEach(c=>c.observer.setOptions(c.defaultedQueryOptions,t));const o=a.map(c=>c.observer),y=o.map(c=>c.getCurrentResult()),R=o.some((c,C)=>c!==i[C]);i.length===o.length&&!R||(h(this,p,o),h(this,f,y),this.hasListeners()&&(z(i,o).forEach(c=>{c.destroy()}),z(o,i).forEach(c=>{c.subscribe(C=>{d(this,u,D).call(this,c,C)})}),d(this,u,F).call(this)))})}getCurrentResult(){return n(this,f)}getQueries(){return n(this,p).map(e=>e.getCurrentQuery())}getObservers(){return n(this,p)}getOptimisticResult(e,s){const i=d(this,u,M).call(this,e).map(a=>a.observer.getOptimisticResult(a.defaultedQueryOptions));return[i,a=>d(this,u,A).call(this,a??i,s),()=>d(this,u,k).call(this,i,e)]}},Q=new WeakMap,f=new WeakMap,v=new WeakMap,E=new WeakMap,p=new WeakMap,O=new WeakMap,q=new WeakMap,S=new WeakMap,u=new WeakSet,k=function(e,s){const t=d(this,u,M).call(this,s);return t.map((i,a)=>{const o=e[a];return i.defaultedQueryOptions.notifyOnChangeProps?o:i.observer.trackResult(o,y=>{t.forEach(R=>{R.observer.trackProp(y)})})})},A=function(e,s){return s?((!n(this,O)||n(this,f)!==n(this,S)||s!==n(this,q))&&(h(this,q,s),h(this,S,n(this,f)),h(this,O,T(n(this,O),s(e)))),n(this,O)):e},M=function(e){const s=new Map(n(this,p).map(i=>[i.options.queryHash,i])),t=[];return e.forEach(i=>{const a=n(this,Q).defaultQueryOptions(i),o=s.get(a.queryHash);o?t.push({defaultedQueryOptions:a,observer:o}):t.push({defaultedQueryOptions:a,observer:new G(n(this,Q),a)})}),t},D=function(e,s){const t=n(this,p).indexOf(e);t!==-1&&(h(this,f,re(n(this,f),t,s)),d(this,u,F).call(this))},F=function(){var e;if(this.hasListeners()){const s=n(this,O),t=d(this,u,A).call(this,d(this,u,k).call(this,n(this,f),n(this,v)),(e=n(this,E))==null?void 0:e.combine);s!==t&&P.batch(()=>{this.listeners.forEach(i=>{i(n(this,f))})})}},U);function ne({queries:r,...e},s){const t=Z(),i=_(),a=j(),o=w.useMemo(()=>r.map(l=>{const g=t.defaultQueryOptions(l);return g._optimisticResults=i?"isRestoring":"optimistic",g}),[r,t,i]);o.forEach(l=>{J(l),V(l,a)}),W(a);const[y]=w.useState(()=>new ie(t,o,e)),[R,c,C]=y.getOptimisticResult(o,e.combine);w.useSyncExternalStore(w.useCallback(l=>i?X:y.subscribe(P.batchCalls(l)),[y,i]),()=>y.getCurrentResult(),()=>y.getCurrentResult()),w.useEffect(()=>{y.setQueries(o,e,{listeners:!1})},[o,e,y]);const H=R.some((l,g)=>N(o[g],l))?R.flatMap((l,g)=>{const m=o[g];if(m){const I=new G(t,m);if(N(m,l))return $(m,I,a);Y(l,i)&&$(m,I,a)}return[]}):[];if(H.length>0)throw Promise.all(H);const x=R.find((l,g)=>{const m=o[g];return m&&ee({result:l,errorResetBoundary:a,throwOnError:m.throwOnError,query:t.getQueryCache().get(m.queryHash)})});if(x!=null&&x.error)throw x.error;return c(C())}const ae=async(r,e,s)=>{try{return(await se.get(`/v2/menu/${r}/dishes`,{params:{category:e},signal:s})).data.data}catch(t){if(te.isCancel(t)){console.debug("Get dishes request cancelled");return}throw console.error(`Failed to fetch dishes by category: ${e}`,t),t}},he=(r,e,s)=>ne({queries:r.map(t=>({queryKey:["categoryDishes",t.categoryName],queryFn:async({signal:i})=>{const a=await ae(e,t.categoryName,i);return{categoryName:t.categoryName,dishes:a}},enabled:!!r&&!!e&&t.dishIds.length>0&&s,refetchOnWindowFocus:!1,staleTime:1/0})),combine:t=>({categoryData:t.map(i=>i.data).filter(Boolean),isQueriesSuccess:t.every(i=>i.isSuccess)})});export{he as u};
